---
applyTo: "**"
---

# Next.js Best Practices for LLMs (2025)

_Last updated: August 2025_

This document summarizes the latest, authoritative best practices for building, structuring, and maintaining Next.js applications. It is intended for use by LLMs and developers to ensure code quality, maintainability, and scalability.

---

## 1. Project Structure and Conventions
When building with the App Router in Next.js, project structure must remain clean, predictable, and consistent. The /app directory should be dedicated only to routing, while shared code is stored at the root level.

### 1.1 Top-Level Folders
- /app - Defines routes, layouts, error boundaries, loading states, and API endpoints.
- /public - Static assets served directly from the root (e.g., images, fonts, favicon).
- /components - Reusable UI components shared across routes.
- /lib - Utility functions, API clients, and shared server logic.
- /hooks - Custom React hooks.
- /styles - Global stylesheets or theme files.
- /types - Typescript type definitions
- /contexts - React Context Providers
- /api - API routing

### 1.2 Routing Files (/app)
These are folders that server as routes under the /app directory. If possible it must have these files:
- layout.tsx - Shared UI
- page.tsx - Route entry point
- loading.tsx - Suspense fallback
- not-found.tsx - 404 UI
- error.tsx - Error boundary for the segment
- route.tsx - API endpoint
- global-error.tsx - App-wide error boundary (ask for my opinion on this as this can be shared between routes)

### 1.2.1 Dynamic Routes
These are routes with slugs in this format [slug]. For example app/blog/[slug]/page.tsx where slug is the dynamic parameter.

### 1.2.2 Route Groups & Private Folders
- use (group) to organize or group routes without chaging URL. For example: (public) for public pages.
- use _folder for non-routable utilities (the underscore indicates that the folder/route is private)

### 1.3 Colocation
Colocate only styles and tests with the route where they are used. Do not colocate shared logic inside /app.

### 1.4 Naming Conventions
  - Use `PascalCase` for component files and exports (e.g., `UserCard.tsx`).
  - Use `camelCase` for hooks (e.g., `useUser.ts`).
  - Use `snake_case` or `kebab-case` for static assets (e.g., `logo_dark.svg`).
  - Name context providers as `XyzProvider` (e.g., `ThemeProvider`).
  - Match the component name to the file name.
  - For single-export files, default export the component.
  - For multiple related components, use an `index.ts` barrel file.

---

## 2. Server and Client Components
Never use next/dynamic with { ssr: false } inside a Server component. This is not suppored 
This bloats the client-side bundle, increases hydration cost, and slows down page load.

### 2.1 Avoid Overusing Client Components
This assumes to **only** use 'useClient' when absolutely need/strictly required for interactivity (useState, useEffect, context, refs)
- Use server components by default
- Split large client components into smaller interactive parts

### 2.2 Avoid Unoptimized Server-Side Rendering Usage
- For **static** data, prefer to implement Static Site generation or Incremental Static Regeneration
- Use server-side data fetching (fetch in server components) with caching enabled where possbile
- For highly dynamic data, cache at the edge or API layer, not just in Next.js

### 2.3 Client-Side Data Fetching in Interactive Pages
- Avoid fetching data in client components (such as using useEffect to fetch)
- Prefer to fetch data in server components! This is important!

### 2.4 Avoid Excessive Hydration
- Use Progress Hydration if possible (but designing components into smaller parts help)
- Avoid wrapping the whole layout in 'useClient'
- Keep global layout and navigation server-rendered unless absolutely interactive

### 2.5 Usage of Server and Client
- Treat server components as the data and render layer
- Treat client components as the interaction layer
- Always take into consideration if the component requires interactivity before making it client-side

---

## 3. API Routes

### 3.1 General Guidelines
- Export async functions named after HTTP verbs (GET, POST, PUT, DELETE) inside /app/api/.../route.ts.
- Keep /app/api strictly for request/response handling. Extract all business logic into /lib or /services.
- Prefer direct data fetching in Server Components when possible. Only use API Routes for:
  - External consumption (mobile apps, 3rd-party integrations).
  - Authenticated mutations (POST, PUT, DELETE).
  - Cases requiring custom headers, middleware, or edge runtime.
 
### 3.2 Error Handling
- Always use strict HTTP status codes (400, 401, 403, 404, 500) instead of returning 200 with error payloads.
- Return a consisten JSON format for errors. { "error": "Message here", "code": 401 }

### 3.3 Security
- Always validate reqeuest bodies: input validation, authentication, and rate limiting

---

## 4. Styling (SCSS, Global, Tailwind)

### 4.1 General Guidelines for SCSS/CSS, Global
- Use CSS Modules for component-level styles. Name files with the `.module.css` extension.
- For global styles put it in `app/styles/name.css`. Use this for resets, typography, and other global styles.

### 4.2 Tailwind
- Color palette must be consistent
- Use responsive design principles and use container queries best practices
- Ensure sufficient color contrast for accessibility
- Use consistent spacing and layout
- Maintain semantic HTML structure
- Use utility-first classes directly in markup whenever possible

---

## 5. General Best Practices
Keep in mind the previous sections. These are general guidelines when coding for better developer experience and clean code.

### 5.1 TypeScript First
- Always use TypeScript for all files (.ts / .tsx).
- Enable strict mode in tsconfig.json to enforce type safety.
- Prefer interfaces for object shapes and types for unions/aliases.
- Use unknown instead of any unless unavoidable.

### 5.2 Code Formating and Linting
- Enforce code style and linting. Use the official Next.js ESLint config.
- Store secrets in .env.development.local. Never commit secrets to version control.

### 5.3 Documentation
- Write clear README and code comments
- Document public APIs and components
- When adding new features or making significant changes, create a FEATURE_README.md (where FEATURE is the feature name) in app/changelogs

## 6. Agent Role
- Ask questions if you are unsure about the implementation details, design choices, or need clarification on the requirements
- Always answer in the same language as the question, but use english for the generated content like code, comments or docs
- Always use the latest documentation and guides
- For every nextjs related request, begin by searching for the most current nextjs documentation, guides, and examples.
- Use the following tools to fetch and search documentation if they are available:
  - `resolve_library_id` to resolve the package/library name in the docs.
  - `get_library_docs` for up to date documentation.
